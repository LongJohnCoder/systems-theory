/*++

Copyright (c) Aleksey Bragin.  All rights reserved.

    THIS CODE AND INFORMATION IS PROVIDED UNDER THE LESSER GNU PUBLIC LICENSE.
    PLEASE READ THE FILE "COPYING" IN THE TOP LEVEL DIRECTORY.

Module Name:

    bus.c

Abstract:

    PnP ISA Bus Extender

Environment:

    Kernel mode

Revision History:

    Aleksey Bragin - 

--*/
#include "precomp.h"

#ifdef ALLOC_PRAGMA
#pragma alloc_text(PAGE, PipInitializeDeviceInfo)
#pragma alloc_text(PAGE, PipCreateReadDataPort)
#endif

PDEVICE_INFORMATION PipRDPNode;
PHYSICAL_ADDRESS ADDRESS_PORT = {0x279, 0};
PHYSICAL_ADDRESS BusAddress = {0xA79, 0};

/*++
 * @name PipInitializeDeviceInfo
 *
 * The PipInitializeDeviceInfo routine FILLMEIN
 *
 * @param DeviceInformation
 *        FILLMEIN
 *
 * @param CardInformation
 *        FILLMEIN
 *
 * @param LogicalDeviceNumber
 *        FILLMEIN
 *
 * @return VOID
 *
 * @remarks Documentation for this routine needs to be completed.
 *
 *--*/
VOID
PipInitializeDeviceInfo(IN PDEVICE_INFORMATION DeviceInformation,
                        IN PCARD_INFORMATION CardInformation,
                        IN USHORT LogicalDeviceNumber)
{
    //
    // Clear it
    //
    RtlZeroMemory(DeviceInformation, sizeof(DEVICE_INFORMATION));

    //
    // Set card information and device number
    //
    DeviceInformation->CardInformation = CardInformation;
    DeviceInformation->LogicalDeviceNumber = LogicalDeviceNumber;

    //
    // Set the device as disabled for now
    //
    DeviceInformation->Flags = DF_NOT_FUNCTIONING;

    //
    // Set the power state
    //
    DeviceInformation->DevicePowerState = PowerSystemWorking;
}

/*++
 * @name PipCreateReadDataPortBootResources
 *
 * The PipCreateReadDataPortBootResources routine FILLMEIN
 *
 * @param DeviceInformation
 *        FILLMEIN
 *
 * @return NTSTATUS
 *
 * @remarks Documentation for this routine needs to be completed.
 *
 *--*/
NTSTATUS
PipCreateReadDataPortBootResources(IN PDEVICE_INFORMATION DeviceInformation)
{
    PCM_RESOURCE_LIST ResourceList;
    PCM_PARTIAL_RESOURCE_LIST PartialList;
    PCM_PARTIAL_RESOURCE_DESCRIPTOR PartialDescriptor;
    ULONG TotalSize;
    ULONG Port;
    ULONG i;

    //
    // Allocate the resource list and two descriptors
    //
    TotalSize = sizeof(CM_RESOURCE_LIST) + 2 * sizeof(*PartialDescriptor);
    ResourceList = ExAllocatePoolWithTag(PagedPool, TotalSize, 'Isap');
    if (!ResourceList)
    {
        //
        // No memory; fail
        //
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Clear the structures
    //
    RtlZeroMemory(ResourceList, TotalSize);

    //
    // Setup the count and get the partial list
    //
    ResourceList->Count = 1;
    PartialList = &ResourceList->List[0].PartialResourceList;

    //
    // Initialize the partial list
    //
    PartialList->Version = 0;
    PartialList->Revision = 0x3000;
    PartialList->Count = 2;

    //
    // Get the partial descriptor and loop
    //
    PartialDescriptor = &PartialList->PartialDescriptors[0];
    for (i = 0; i < 2; i++)
    {
        //
        // Set the header information
        //
        PartialDescriptor->Type = CmResourceTypePort;
        PartialDescriptor->ShareDisposition = CmResourceShareDeviceExclusive;
        PartialDescriptor->Flags = CM_RESOURCE_PORT_IO;

        //
        // Check if we're doing the bus address or the address port
        //
        Port = (i) ? ADDRESS_PORT.LowPart : BusAddress.LowPart;

        //
        // Set the port data
        //
        PartialDescriptor->u.Port.Start.LowPart = Port;
        PartialDescriptor->u.Port.Length = 1;

        //
        // Go to the next descriptor
        //
        PartialDescriptor++;
    }

    //
    // Link this data to the device information
    //
    DeviceInformation->BootResources = ResourceList;
    DeviceInformation->BootResourcesLength = TotalSize;

    //
    // Return success
    //
    return STATUS_SUCCESS;
}

/*++
 * @name PipCreateReadDataPort
 *
 * The PipCreateReadDataPort routine FILLMEIN
 *
 * @param DeviceExtension
 *        FILLMEIN
 *
 * @return NTSTATUS
 *
 * @remarks Documentation for this routine needs to be completed.
 *
 *--*/
NTSTATUS
PipCreateReadDataPort(IN PPI_BUS_EXTENSION DeviceExtension)
{
    PDEVICE_OBJECT DeviceObject;
    NTSTATUS Status;
    PDEVICE_INFORMATION DeviceInformation;

    //
    // Create the device
    //
    Status = IoCreateDevice(PipDriverObject,
                            4,
                            NULL,
                            FILE_DEVICE_BUS_EXTENDER,
                            FILE_AUTOGENERATED_DEVICE_NAME,
                            FALSE,
                            &DeviceObject);
    if (!NT_SUCCESS(Status)) return Status;

    //
    // Allocate the Device Information structure
    //
    DeviceInformation = ExAllocatePoolWithTag(NonPagedPool,
                                              sizeof(DEVICE_INFORMATION),
                                              'iPnP');
    if (!DeviceInformation)
    {
        //
        // Fail!
        //
        PipDebugPrint(0, "PnpIsa:failed to allocate DEVICEINFO structure\n");
        IoDeleteDevice(DeviceObject);
        return STATUS_INSUFFICIENT_RESOURCES;
    }

    //
    // Initialize it
    //
    PipInitializeDeviceInfo(DeviceInformation, NULL, 0);
    Status = PipCreateReadDataPortBootResources(DeviceInformation);
    if (!NT_SUCCESS(Status))
    {
        //
        // Fail!
        //
        IoDeleteDevice(DeviceObject);
        ExFreePool(DeviceInformation);
        return Status;
    }

    //
    // Link the device object
    //
    DeviceInformation->PhysicalDeviceObject = DeviceObject;

    //
    // Copy the flags over, and set us as an enumerated data port
    //
    DeviceInformation->Flags &= ~ DF_NOT_FUNCTIONING;
    DeviceInformation->Flags |= (DF_READ_DATA_PORT | DF_ENUMERATED);

    //
    // Link us to the device object and the device extension
    //
    DeviceObject->DeviceExtension = DeviceInformation;
    DeviceInformation->ParentDeviceExtension = DeviceExtension;

    //
    // Set us as the RDP Node
    //
    PipRDPNode = DeviceInformation;

    //
    // Lock the database
    //
    PipLockDeviceDatabase();

    //
    // Insert us into the device list
    //
    PushEntryList(&DeviceExtension->DeviceList,
                  &DeviceInformation->DeviceList);

    //
    // Unlock the database
    //
    PipUnlockDeviceDatabase();

    //
    // Initialization complete
    //
    DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

    //
    // Return success
    //
    return Status;
}

